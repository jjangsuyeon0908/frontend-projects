var name = '홍길동';
console.log(name);

var name = '김길동';
console.log(name);

name = '김수현';
console.log(name);
----------
let name = '홍길동';
console.log(name);

// let name = '김길동';  // 재선언 불가능
// console.log(name);

name = '김수현';
console.log(name);
----------
const name = '홍길동';
console.log(name);

// const name = '김길동'; // 재선언 불가능
// console.log(name);

// name = '김수현';  // 재할당 불가능
// console.log(name);
----------
var –nium = 'helo'; // 생성 규칙을 만족하지 못하여 사용 X

var 9nium = 'helo'; // 생성 규칙을 만족하지 못하여 사용 X

var n9ium = 'helo'; // 생성 규칙을 만족하여 사용 O

var $n$um = 'helo'; // 생성 규칙을 만족하여 사용 O

var data = 'helo';

console.log(data);

console.log(dAta); // 선언 하지 않은 변수

var var = 'helo'; // 생성 규칙을 만족하지 못하여 사용 X

// var let 의 경우 사용은 되지만 사용하지 않는 것을 권장
----------
var num = 3.14;

typeof num // number 타입 확인

var flag = true;

typeof flag; // boolean 타입 확인

var str = '안녕';

typeof str; // string 타입 확인

var date = new Date('2025-01-24');

typeof date; // Object 타입 확인

var unknwon;

typeof unknown; // undefined 타입 확인

var tmp = null;

tmp // 값이 null 인 것을 확인
----------
let a = 10;
let b = 5;

console.log(a + b); // 15 (덧셈)
console.log(a - b); // 5  (뺄셈)
console.log(a * b); // 50 (곱셈)
console.log(a / b); // 2  (나눗셈)
console.log(a % b); // 0  (나머지)
console.log(a ** b); // 100000 (거듭제곱)
----------
let a = 5; 

a += 3; // a = a + 3; (a의 값은 8) 
a -= 2; // a = a - 2; (a의 값은 6) 
a *= 2; // a = a * 2; (a의 값은 12) 
a /= 3; // a = a / 3; (a의 값은 4) 

console.log(a); // 4
----------
let x = 5; // 0101 (총 32비트)
let y = 3; // 0011

console.log(x & y); // 1  (0101 & 0011 => 0001)
console.log(x | y); // 7  (0101 | 0011 => 0111)
console.log(x ^ y); // 6  (0101 ^ 0011 => 0110)
console.log(x << y); // 40 (0101 << 3 => 101000)
console.log(x >> 2); // 1 (0101 >> 2 => 0001)
----------
/*
점수가 90점 이상일때는 A
점수가 80점 이상일때는 B
점수가 70점 이상일때는 C
점수가 60점 이상일때는 D
그 외의 경우에는 F 가 나오도록 중첩된 삼항 연산자를 작성하세요
*/
let score = 63;

let grade = score >= 90 ? "A" : score >= 80 ? "B" : score >= 70 ? "C" : score >= 60 ? "D" : "F";

console.log(grade);
--------------------------------------------------
템플릿 리터럴
- 리터럴이란 데이터의 값을 표현하는 방식을 의미
- 문자열을 다루는 새로운 방법으로, 백틱(`)을 사용하여 문자열을 정의하는 방식
- 문자열을 보다 쉽게 작성하고, 변수나 표현식을 문자열 내에서 삽입할 수 있는 기능을 제공
- ${} 구문을 사용하여 문자열 내에 변수나 자바스크립트 표현식을 삽입

1. 변수 및 표현식 삽입
${} 구문을 사용하여 문자열 내에 변수나 자바스크립트 표현식을 삽입

const name = "Alice";
const age = 25;

// const greeting = "Hello, My Name is " + name + " and I am " + age + " years old";
const greeting = `Hello, My Name is ${name} and I am ${age} years old`;

2. 멀티라인 문자열

const message = "안녕하세요.\n" +
"자바스크립트는 정말 멋진 언어입니다!\n" +
"새로운 기능들을 잘 활용해보세요";

console.log(message);

const message = `안녕하세요.
자바스크립트는 정말 멋진 언어입니다!
새로운 기능들을 잘 활용해보세요`;

console.log(message);

3. 다양한 표현식 사용 가능
템플릿 리터럴 안에서 자바스크립트 표현식을 사용할 수 있음
즉, 함수 호출이나 계산된 값을 바로 문자열에 삽입

const num1 = 10;
const num2 = 20;

const result = `The sum of ${num1} and ${num2} is ${num1 + num2}.`;
console.log(result);
--------------------------------------------------
객체 리터럴
자바스크립트에서 객체를 생성하는 간단하고 직관적인 방법
객체 리터럴은 중괄호({})를 사용하여 여러 프로퍼티(속성)와 메소드(함수)를 정의하는 방식

let obj = {
  key1: value1,
  key2: value2
  // ...
};

let person = {
  name: "Alice",
  age: 36,
  isEmployed: true
};

console.log(person.name);
console.log(person.age);
console.log(person.isEmployed);
--------------------------------------------------
자바스크립트 배열이란?
- 여러 개의 값을 순서대로 저장할 수 있는 데이터 구조
- 자바스크립트에서 매우 중요한 요소로, 값의 리스트나 컬렉션을 다룰때 자주 사용
- 대괄호 []를 사용하여 선언하며, 대괄호 안에 쉼표(,)로 구분된 요소들을 나열

특징

1. 인덱스 기반
- 각 요소가 0부터 시작하는 인덱스를 가지며, 해당 인덱스를 사용하여 요소에 접근

let fruits = ["apple", "banana", "cherry"];
console.log(fruits[0]);
console.log(fruits[2]);

2. 동적 크기
- 크기가 동적으로 조정
- 요소를 추가하거나 삭제할 수 있으며, 배열 크기는 자동으로 변경

let numbers = [1,2,3];

numbers.push(4);
console.log(numbers);

3. 다양한 데이터 타입
- 다양한 데이터 타입을 혼합하여 저장

let mixedArray = [1, "text", true, { key: "value"}];
console.log(mixedArray[3]);

4. 배열 길이
배열의 길이는 length 속성을 통해 확인

let items = [1,2,3,4,5];
console.log(items.length);

5. 배열 메서드

push() : 배열의 끝에 요소를 추가

const numbers = [1, 2];

numbers.push(3);
console.log(numbers); 

pop() : 배열의 마지막 요소를 제거하고 반환

const numbers = [1, 2, 3];
let last = numbers.pop();

console.log(last);
console.log(numbers);

shift(): 배열의 첫 번째 요소를 제거하고 반환

const numbers = [1, 2, 3];
let first = numbers.shift();

console.log(first);
console.log(numbers);

unshift() : 배열의 앞에 요소를 추가
let numbers = [2, 3];
numbers.unshift(1);

console.log(numbers);

forEach(): 배열의 각 요소에 대해 주어진 콜백 함수를 실행

let fruits = ["apple", "banana", "cherry"];

fruits.forEach((fruit) => {
  console.log(fruit);
});

map(): 배열의 각 요소에 대해 주어진 함수를 호출하고, 그 결과로 새로운 배열을 생성
let numbers = [1,2,3];
let doubled = numbers.map(num => num * 2);
console.log(doubled);

filter(): 조건을 만족하는 요소들만으로 새로운 배열을 생성
let numbers = [1,2,3,4];
let evens = numbers.filter(num => num % 2 === 0);

console.log(evens);

reduce(): 배열을 순회하면서 하나의 값으로 변경

let numbers = [1,2,3,4]

let sum = numbers.reduce((total, num) => total + num, 0);

console.log(sum);

다차원 배열
- 배열 안에 또 다른 배열을 요소로 포함
- 이를 다차원 배열

let matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];

console.log(matrix[1][2]);
--------------------------------------------------
호이스팅이란?
- 자바스크립트의 고유한 동작 방식
- 변수와 함수의 선언이 실행 컨텍스트의 최상위로 끌어올려지는 것처럼 동작

1. 변수 호이스팅

// 원래는 에러가 발생해야 하지만 에러가 발생하지 않음
console.log(myVar); // undefined
var myVar = 5;
console.log(myVar); // 5

=> 
실제는 아래와 같이 동작하기 때문

var myVar;
console.log(myVar);
myVar = 5;
console.log(myVar);

2. 함수 호이스팅
// 함수에 대해서 설명하면서 설명
--------------------------------------------------
자바스크립트 함수
- 특정 작업을 수행하는 코드 블록
- 반복적으로 사용되는 로직을 재사용 할 수 있도록 함

1. 함수 선언
- 함수 이름과 함께 정의하는 가장 기본적인 방법
- 함수 선언문이라고 불리며 호이스팅에 의해 함수 정의가 코드 어디든 호출전에 사용 됨

function 함수이름(매개변수1, 매개변수2, ...) 
{
  // 함수가 실행할 코드
  return 반환값;
}

e.g.

function greet(name)
{
  return `Hello, ${name}!`;
}

console.log(greet("Alice"));

-----
호이스팅 확인
-----

console.log(greet("Alice"));

function greet(name)
{
  return `Hello, ${name}!`;
}

-----
this 객체란?

1. 전역 컨텍스트
- 브라우저 환경에서는 전역 객체가 window
- Node.js 환경에서는 global 객체

console.log(this);

function showThis()
{
  console.log(this);
}

const obj = {
  name: 'Alice',
  greet: function() {
    console.log(this);
    console.log(this.name);
  }
};

2. 함수 표현식
- 함수 표현식은 함수를 변수에 할당하는 방식
- 선언된 함수는 이름이 없는 함수(익명 함수)가 될 수 있다
- 호이스팅이 되지 않으므로 함수가 정의된 직후에나 호출할 수 있다

const 함수이름 = function(매개변수1, 매개변수2, ...)
{
  // 함수가 실행할 코드
  return 반환값;
}

e.g.

const greet = function(name) 
{
  return `Hello, ${name}!`;
};

console.log(greet("Alice"));

typeof greet; // function
-----
호이스팅 확인
-----
console.log(greet("Alice"));

const greet = function(name) 
{
  return `Hello, ${name}!`;
};

3. 화살표 함수
- 간견할 문법으로 함수를 작성할 수 있는 방법
- 화살표 함수는 익명 함수로 주로 사용되며, this 바인딩에 차이가 있다
- 함수 표현식의 종류 중 하나이기 때문에 호이스팅 되지 않는다.

const 함수이름 = (매개변수1, 매개변수2, ...) => {
    // 함수가 실행할 코드
    return 반환값;
};

-----
예제1 - 기본화살표 함수
-----
const greet = (name) => {
  return `Hello, ${name}!`;
};

console.log(greet("Alice"));